
=== LSTNEW ========================================================

The purpose is that you have somestruct, and you create a fresh new link fith one member. So this new member gets 3 values, content, size and next.
Function will be called: somestruct = lstnew(somecontent, size);

There is a structX defined in libft.h
Function gest 2 args: pointer content, size of content
Vars: type structX new, rcontent, rsize
Allocates malloc to new, type of structX, sizeof structX
Check if arg content is not NULL
	rcontent gets memalloc with size of arg size
	var rsize gets value of arg size
	rcontent gets arg content via func memcpy, arg size
	

=== LST CLEAR ======================================================



====================================================================


=== LST MAP ======================================================

Arguments: *list, void* pt to function f, void pt to function del
Vars: newlist, current, temp

Check if list or func exist (only 1 fuction ??)
Check if content in arg list is not null, or return 0
Put arg list into newlist via creator
Put newlist into curr
Make list point to itselft next
Loop until list
	f performs on content of list (maybe modifies this content)
	the modified result is put into temp via creator
	if the result of above is null, return 0

	Rochade, next of current becomes temp, current becomes temp,
	list becomes list->next

====================================================================

CALLOC, MALLOC, MEMSET

void (int count, int size)
Vars: new pointer, index
Check if count is 0, then give null
Make memory !!comes from argument!
Loop: until count
	make each zero
return pointer

MALLOC

MEMSET

====================================================================

MEMCCPY 
- Copies n bytes from src to dest. 
- It stops at c in src. 
- Returns the byte after c. 
- If no c is found, returns NULL. 
- Should not overlap.


Vars: skopiraj args v local vars, index
Loop, index gre do size
	kopira src preko dest
	ce se pojavi c v src, vrne naslednjega od dest (pointer)
	 ,torej od tam v dest, do koder je prestel index
Vrne 0, torej ce je ves size skopiral

====================================================================

MEMCHR AND STRCHR

MAIN (const void str, c , n) 
Vars: index, new str and c (what type!)
Copy str and c into new vars
Loop: until n
	if c matches str[], give pointer to this place in str
	(must also detect \0)
if not found, return 0

	Razlika: memstr must cast, because returns void
	

STRCHR

MAIN (const char str, c)
Vars: index, new str
Copy str into new var
Get lenght of str
Check if c is \0, then must return end of str
Loop: until str
	if c is same as str, give this place in str
return null

====================================================================

MEMMOVE PSEUDO all void, 2x str, len
- Copies n bytes from src to dest. 
- Can overlap. !!! Needs extra code! 
- It takes void, then casts to char*. 
- Returns pointer to original dest. 
- Similar to strlcpy, strncpy, memcpy ...


MAIN
Vars: 2 strings to copy args
Check if both str agrs exist (and or ???)
Copy args into new str
Check both pointers, if one is smaller than other!! Needed for overlap!!
	each newstr gets len minus 1 ?????
	loop decreases len
		copy into dest, from back to start !!!!
Else loop decreases len
	copy into dest, normally
Return original dest

====================================================================

FT_SPLIT
3 pomozne funkcije: prestej besede, wordlen in fill
Vars: 2Darray, nr words, index
Get nr of words (help funk)
Allocate 2Darray with nr of words!!
Loop: until nr of words
	fill 2darray with each word (help funk, 4arg)
Return 2Darray

FILL
Vars: 2 indexes, len
Loop until nr of words
	Loop skip begining delimiters
	Get len of this word (help func)
	Alloc memory for this word
	Loop until len of word
		put this word into place (plus end of word)
Put last place in 2Darray
Return 2Darray
	
COUNT WORDS
Vars: index, nr of words
Loop until str
	Check if: tricky checking 
		(str not dl AND str+1 is dl OR str+1 is end)

====================================================================


STRCHR
Vars: char*
make cast out of const
check if c is \0, must return end of this str
Loop until str, check if c matches, return new place of str
Return null (c was not found)




STRRCHR
Vars: *char
Loop until str
	check if matches
check if c was end of str, give back this end
return found (which can be still null or a new place in str)


====================================================================

FT_STRLCAT PSEUDO

MAIN
2 var: index, dolzina dest (ta ima 2 moznosti: lenDest ali size)
call lenDest via help function
Loop: dokler je size vecja od vsote lenDest, lenSrc + 1 ali src\0
					(za lenSrc je boljse imet index)
	src se kopira na konec dest (mora it preko indexa)
Ce je vsota lenDest in indexa manjsa od size (torej se je celi src skopiral, brez svojega \0)
	v tem primeru dodaj konec stringa
Vrni vsoto lenDest in lenSrc

====================================================================

STRLCPY PSEUDO (dest, src, size)
- Copies n-1 chars from src to dest, 
- Puts \0. Both src and dst must have \0. 
- Returns total length of new string, thus length of src.
- If arg size is <= 0, return size ????
- user must not give size> lendest

Vars: index, len
Check if both arg exist, return 0
You need len of src
Check if size is 0 or less, return len
Loop until end of src AND until size(but save 1 space!)
	copy, increase stuff
end string
return len

====================================================================

FT_STRMAPI PSEUDO
Arguments: str, pointer to function(int, char)
Vars: newstr, c, index
Allocate newstr
Loop until str
	change c via extra function
	put c into newstr
put end, return newstr


====================================================================

STRNCMP PSEUDO
MAIN (2 const strings, n)
vars: only index
Check n, should not be 0
Loop: index goes till one less than n !!!, and till end of both strings
	increase if both chars are same
	if not same, give the difference, but casted !!!
Give the difference of chars 

		Razlika: strncmp primerja ==, memcmp pa primerja !=

MEMCMP PSEUDO
MAIN (2 const strings, n)
vars: 2 const unsigned *chars
Copy both arguments into new vars
Check if n is 0
Loop: n to zero
	if both chars are same, return difference
	decrease n, increase both chars
Return 0 (means that n was reached and all chars were same)

====================================================================

FT_STRTRIM PSEUDO

MAIN
Vars: len, newstring
Check if both str exist, give null
Loop: until str1, until c from str1 is in set (help function)
	increm str, so it travels until unmatched c
set new len (from new position of str)
Loop: from the end of str, until no match (help function)\
	decrease len
set new string (help function, needs start, end!!, origin)
Give new string    


====================================================================

SUBSTR PSEUDO

Returns a chunk (len) of a string (substring), according to start [i]

vars: new string (pointer), index
allocate memory for new string
start must not be at end or past of orig string, return pointer
loop until len
	copy string into new, increase stuff
!!think about the begining of new string
set the \0 of new string
return new string


SIMILAR: 

STRNSTR PSEUDO (2x const char*, size_t)
Vars: 2 new chars, new size
If needle is \0, give hay
Loop: until end of hay and end of size (looking at each hay)
	give all three new values!!
	Loop: until end of new needle, until new needle/hay are same, until new size
		incr/decrement all new
	if needle ended, give place of hay
	increase orig hay, decrease size
return 0 (thus, hay or size reached end) 


====================================================================














    

